package main

import (
	"flag"
	"net"
	"net/rpc"
	"os"
	"sync"

	"uk.ac.bris.cs/gameoflife/gol"
	"uk.ac.bris.cs/gameoflife/util"
)

var mutex sync.Mutex

// var wg sync.WaitGroup

type Broker struct {
	Clients    []*rpc.Client
	World      [][]byte
	AliveCells []util.Cell
	Turn       int
	Resume     chan bool
	Pause      bool
	CellCount  int
}

func (b *Broker) ProcessWorld(req gol.Request, res *gol.Response) error {
	res.World = make([][]byte, req.Parameter.ImageHeight)
	for i := range res.World {
		res.World[i] = make([]byte, req.Parameter.ImageWidth)
	}
	req.Parameter.Threads = len(b.Clients)
	b.Turn = 0
	turn := 0
	b.Resume = make(chan bool)
	mutex.Lock()
	b.World = make([][]byte, req.Parameter.ImageHeight)
	for i := range b.World {
		b.World[i] = make([]byte, req.Parameter.ImageWidth)
	}
	b.World = copySlice(req.World)
	mutex.Unlock()
	// TODO: Execute all turns of the Game of Life.
	//finish := make(chan bool, 1)
	//var wg sync.WaitGroup
	for ; turn < req.Parameter.Turns; turn++ {
		mutex.Lock()
		if b.Pause {
			mutex.Unlock()
			<-b.Resume
		} else {
			mutex.Unlock()
		}
		start := 0
		end := req.Parameter.ImageHeight
		request := new(gol.Request)
		request.World = copySlice(b.World)
		request.Start = start
		request.End = end
		response := new(gol.Response)
		b.Clients[0].Call(gol.ProcessGol, request, response)
		res.World = copySlice(response.World)
		b.World = copySlice(res.World)
		b.Turn++
	}
	// for i := 0; i < req.Parameter.Threads; i++ {
	// 	req.Start = i * (req.Parameter.ImageHeight / req.Parameter.Threads)
	// 	req.End = (i + 1) * (req.Parameter.ImageHeight / req.Parameter.Threads)
	// 	// if i == req.Parameter.Threads-1 {
	// 	// 	req.End = req.Parameter.ImageHeight
	// 	// }
	// 	mutex.Lock()
	// 	worldCopy := copySlice(b.World)
	// 	mutex.Unlock()
	// 	wg.Add(1)
	// 	go func(client *rpc.Client, i int) {

	// 		reqSlice := gol.Request{World: worldCopy, Start: req.Start, End: req.End}
	// 		resSlice := new(gol.Response)
	// 		client.Call(gol.ProcessGol, reqSlice, resSlice)
	// 		//fmt.Println("received the result from", i)
	// 		mutex.Lock()
	// 		start := i * (req.Parameter.ImageHeight / req.Parameter.Threads)
	// 		for j := start; j < start+len(resSlice.World); j++ {
	// 			fmt.Println(req.World[j])
	// 			fmt.Println(j - req.Start)
	// 			fmt.Println(len(resSlice.World))
	// 			//fmt.Println(resSlice.World[j-req.Start])
	// 			copy(req.World[j], resSlice.World[j-start])
	// 		}
	// 		mutex.Unlock()
	// 		wg.Done()
	// 		finish <- true
	// 	}(b.Clients[i], i)
	// 	wg.Wait()
	// 	// mutex.Unlock()
	// 	//for i := 0; i < req.Parameter.Threads; i++ {
	// 	//	<-finish
	// 	//}
	// }

	//mutex.Lock()

	//b.World = copySlice(req.World)
	//req.World = copySlice(b.World)
	//fmt.Println(len(b.World))

	// b.World = copySlice(req.World)
	// b.CellCount = len(calculateAliveCells(req.Parameter, b.World))
	// b.Turn++
	// mutex.Unlock()
	//fmt.Println("the final turn is", b.Turn)
	//}
	//send the finished world and AliveCells to respond
	mutex.Lock()
	res.World = copySlice(b.World)
	res.AliveCells = calculateAliveCells(req.Parameter, b.World)
	res.CompletedTurns = b.Turn
	//b.World = nil
	mutex.Unlock()
	return nil
}

func (b *Broker) CountAliveCell(req gol.Request, res *gol.Response) error {
	mutex.Lock()
	res.Turns = b.Turn
	res.CellCount = b.CellCount
	mutex.Unlock()
	return nil
}

func (b *Broker) KeyGol(req gol.Request, res *gol.Response) error {
	if req.S {
		mutex.Lock()
		res.Turns = b.Turn
		res.World = copySlice(b.World)
		mutex.Unlock()
	} else if req.P {
		mutex.Lock()
		b.Pause = !b.Pause
		mutex.Unlock()
		if !b.Pause {
			b.Resume <- true
		}
	} else if req.K {
		os.Exit(0)
	}
	return nil
}

func copySlice(src [][]byte) [][]byte {
	dst := make([][]byte, len(src))
	for i := range src {
		dst[i] = make([]byte, len(src[i]))
		copy(dst[i], src[i])
	}
	return dst
}

func calculateAliveCells(p gol.Params, world [][]byte) []util.Cell {
	var aliveCell []util.Cell
	for row := 0; row < p.ImageHeight; row++ {
		for col := 0; col < p.ImageWidth; col++ {
			if world[row][col] == 255 {
				aliveCell = append(aliveCell, util.Cell{X: col, Y: row})
			}
		}
	}
	return aliveCell
}

func main() {
	addresses := []string{
		"127.0.0.1:8040",
		"127.0.0.1:8051",
		//"127.0.0.1:8060",
		//"127.0.0.1:8070",
	}
	clients := make([]*rpc.Client, 1)
	for n := 0; n < 1; n++ {
		clients[n], _ = rpc.Dial("tcp", addresses[n])
	}
	broker := &Broker{
		Clients: clients,
	}
	err := rpc.Register(broker)
	if err != nil {
		return
	}
	pAddr := flag.String("port", "8030", "port to listen on")
	//create a listener to listen to the distributor on the port
	listener, _ := net.Listen("tcp", ":"+*pAddr)
	defer listener.Close()
	rpc.Accept(listener)
}
